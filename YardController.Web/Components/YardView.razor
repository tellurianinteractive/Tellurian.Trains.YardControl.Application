@using Tellurian.Trains.YardController.Model
@using Tellurian.Trains.YardController.Model.Control
@using Tellurian.Trains.YardController.Model.Control.Extensions
@using YardController.Web.Resources
@using YardController.Web.Services
@using System.Globalization
@inject IBufferedKeyReader BufferedKeyReader
@inject ITrainRouteNotificationService TrainRouteNotifications
@inject IPointPositionService PointPositionService
@inject ISignalStateService SignalStateService
@inject IYardDataService YardDataService
@inject IYardController YardController
@implements IDisposable

<svg viewBox="0 0 @ViewBoxWidth @TotalViewBoxHeight" class="yard-view" xmlns="http://www.w3.org/2000/svg" style="user-select: none;">
    <!-- Background -->
    <rect fill="#1a1a1a" width="100%" height="100%"/>

    <!-- Station name -->
    @if (!string.IsNullOrEmpty(Topology.Name))
    {
        @((MarkupString)$"""
            <text
                x="{ViewBoxWidth / 2}"
                y="{TitleFontSize}"
                text-anchor="middle"
                fill="white"
                font-size="{TitleFontSize}"
                font-family="sans-serif"
                font-weight="bold">
                {System.Web.HttpUtility.HtmlEncode(TranslateLabel(Topology.Name))}
            </text>
            """)
    }

    <!-- Grid (for debugging/alignment) -->
    @if (ShowGrid)
    {
        <g id="grid" stroke="#333" stroke-width="0.5">
            @for (int col = 0; col <= Topology.MaxColumn + 1; col++)
            {
                var x = col * CellSize;
                <line x1="@x" y1="0" x2="@x" y2="@ViewBoxHeight" />
            }
            @for (int row = 0; row <= Topology.MaxRow + 1; row++)
            {
                var y = row * CellSize;
                <line x1="0" y1="@y" x2="@ViewBoxWidth" y2="@y" />
            }
        </g>
    }

    <!-- Track links (base layer: inactive first, active on top) -->
    <g id="tracks" stroke-width="@TrackThickness" fill="none" stroke-linecap="round">
        @foreach (var link in Topology.Graph.Links.Where(l => !_activeRouteLinks.Contains(l)))
        {
            var (x1, y1) = ToPixel(link.FromNode.Coordinate);
            var (x2, y2) = ToPixel(link.ToNode.Coordinate);
            <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="white" />
        }
        @foreach (var link in _activeRouteLinks)
        {
            var (x1, y1) = ToPixel(link.FromNode.Coordinate);
            var (x2, y2) = ToPixel(link.ToNode.Coordinate);
            <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="#00cc00" />
        }
    </g>

    <!-- Features layer (on top of tracks) -->

    <!-- Gaps (occupancy dividers) - rendered as perpendicular lines on links -->
    <g id="gaps">
        @foreach (var gap in Topology.Gaps)
        {
            @if (gap.LinkEnd.HasValue)
            {
                // Explicit link gap - render at midpoint of specified link
                var (x1, y1) = ToPixel(gap.Coordinate);
                var (x2, y2) = ToPixel(gap.LinkEnd.Value);
                var midX = (x1 + x2) / 2.0;
                var midY = (y1 + y2) / 2.0;

                var dx = x2 - x1;
                var dy = y2 - y1;
                var len = Math.Sqrt(dx * dx + dy * dy);
                if (len > 0)
                {
                    var perpX = -dy / len;
                    var perpY = dx / len;
                    var g1X = midX + perpX * GapSize;
                    var g1Y = midY + perpY * GapSize;
                    var g2X = midX - perpX * GapSize;
                    var g2Y = midY - perpY * GapSize;

                    <line x1="@F(g1X)" y1="@F(g1Y)" x2="@F(g2X)" y2="@F(g2Y)"
                          stroke="#ff6600" stroke-width="2" />
                }
            }
            else
            {
                // Node gap - find the link containing this coordinate
                var containingLink = FindLinkContaining(gap.Coordinate);
                var (x, y) = ToPixel(gap.Coordinate);

                if (containingLink != null)
                {
                    // Render gap as perpendicular line on the containing link
                    var (x1, y1) = ToPixel(containingLink.FromNode.Coordinate);
                    var (x2, y2) = ToPixel(containingLink.ToNode.Coordinate);

                    var dx = x2 - x1;
                    var dy = y2 - y1;
                    var len = Math.Sqrt(dx * dx + dy * dy);
                    if (len > 0)
                    {
                        var perpX = -dy / len;
                        var perpY = dx / len;
                        var g1X = x + perpX * GapSize;
                        var g1Y = y + perpY * GapSize;
                        var g2X = x - perpX * GapSize;
                        var g2Y = y - perpY * GapSize;

                        <line x1="@F(g1X)" y1="@F(g1Y)" x2="@F(g2X)" y2="@F(g2Y)"
                              stroke="#ff6600" stroke-width="2" />
                    }
                }
                else
                {
                    // No containing link found - draw vertical line as default gap indicator
                    <line x1="@x" y1="@F(y - GapSize)" x2="@x" y2="@F(y + GapSize)"
                          stroke="#ff6600" stroke-width="2" />
                }
            }
        }
    </g>

    <!-- Points (labels and position indicators) -->
    <g id="points">
        @foreach (var point in Topology.Points)
        {
            var (sx, sy) = ToPixel(point.SwitchPoint);
            var divergingEnd = Topology.Graph.DeduceDivergingEnd(point);
            var (divX, divY) = ToPixel(divergingEnd);

            // Deduce straight arm for label positioning
            var straightEnd = Topology.Graph.DeduceStraightArm(point);
            var (strX, strY) = ToPixel(straightEnd);

            // Calculate label position at bisector between straight and diverging
            var (labelX, labelY, labelAngle) = CalculatePointLabelPosition(sx, sy, strX, strY, divX, divY);

            <g class="point" id="point-@point.Label">
                @{
                    var lx = F(labelX);
                    var ly = F(labelY);
                    var la = F(labelAngle);
                }
                @((MarkupString)$"""
                    <text
                        x="{lx}"
                        y="{ly}"
                        text-anchor="middle"
                        dominant-baseline="central"
                        fill="#aaddff"
                        font-size="{PointLabelFontSize}"
                        font-family="sans-serif"
                        font-weight="bold"
                        transform="rotate({la} {lx} {ly})">
                        {System.Web.HttpUtility.HtmlEncode(point.Label)}
                    </text>
                    """)
                @{
                    var (pointNumber, subPointLetter) = GetPointNumberAndSubPoint(point.Label);
                    var position = pointNumber > 0
                        ? (subPointLetter.HasValue
                            ? PointPositionService.GetPosition(pointNumber, subPointLetter.Value)
                            : PointPositionService.GetPosition(pointNumber))
                        : PointPosition.Undefined;
                }
                @if (position != PointPosition.Undefined)
                {
                    // Inactive arm direction (for positioning along the blocked arm)
                    var (inactiveX, inactiveY) = position == PointPosition.Straight ? (divX, divY) : (strX, strY);
                    var armDx = (double)(inactiveX - sx);
                    var armDy = (double)(inactiveY - sy);
                    var armLen = Math.Sqrt(armDx * armDx + armDy * armDy);

                    // Side direction: use the explicit end (always the diagonal arm in the topology)
                    var (expX, expY) = ToPixel(point.ExplicitEnd);
                    var sideDx = (double)(expX - sx);
                    var sideDy = (double)(expY - sy);
                    var sideLen = Math.Sqrt(sideDx * sideDx + sideDy * sideDy);

                    if (armLen > 0 && sideLen > 0 && Math.Abs(sideDy) > 0.01)
                    {
                        var tx = armDx / armLen;
                        var ty = armDy / armLen;
                        var sdx = sideDx / sideLen;
                        var sdy = sideDy / sideLen;

                        var halfH = TrackThickness / 2.0;
                        var halfEdgeW = (TrackThickness / 2.0 + 0.5) / Math.Abs(sdy);
                        var shearX = halfH * sdx / sdy;

                        // Position nearest corner at ~2px from switch point along inactive arm
                        var pr1 = (-shearX - halfEdgeW) * tx + (-halfH) * ty;
                        var pr2 = (-shearX + halfEdgeW) * tx + (-halfH) * ty;
                        var pr3 = (shearX + halfEdgeW) * tx + halfH * ty;
                        var pr4 = (shearX - halfEdgeW) * tx + halfH * ty;
                        var dist = 1.0 - Math.Min(Math.Min(pr1, pr2), Math.Min(pr3, pr4));

                        var pcx = sx + tx * dist;
                        var pcy = sy + ty * dist;

                        var pts = $"{F(pcx - shearX - halfEdgeW)},{F(pcy - halfH)} " +
                                  $"{F(pcx - shearX + halfEdgeW)},{F(pcy - halfH)} " +
                                  $"{F(pcx + shearX + halfEdgeW)},{F(pcy + halfH)} " +
                                  $"{F(pcx + shearX - halfEdgeW)},{F(pcy + halfH)}";
                        <polygon points="@pts" fill="#1a1a1a" />
                    }
                }
            </g>
        }
    </g>

    <!-- Signals (excluding hidden) -->
    <g id="signals">
        @foreach (var signalDef in Topology.Signals.Where(s => s.IsVisible))
        {
            <SignalView Data="@GetSignal(signalDef)" CellSize="@CellSize"
                        IsSelected="@(_selectedFromSignal == signalDef.Name)"
                        OnSignalClicked="OnSignalClicked" />
        }
    </g>

    <!-- Labels -->
    <g id="labels" font-size="@FontSize" font-family="sans-serif">
        @foreach (var label in Topology.Labels)
        {
            var (x1, y1) = ToPixel(label.Start);
            var (x2, y2) = ToPixel(label.End);
            var x = (x1 + x2) / 2.0;
            var y = (y1 + y2) / 2.0;
            var displayText = TranslateLabel(label.Text);
            var textWidth = displayText.Length * 6 + 4; // Approximate width
            var textHeight = FontSize + 4;

            <rect x="@F(x - textWidth / 2.0)" y="@F(y - textHeight / 2.0)"
                  width="@textWidth" height="@textHeight" fill="yellow" />
            @((MarkupString)$"""
                <text
                    x="{F(x)}"
                    y="{F(y)}"
                    text-anchor="middle"
                    dominant-baseline="central"
                    fill="black">
                    {System.Web.HttpUtility.HtmlEncode(displayText)}
                </text>
                """)
        }
    </g>

    <!-- Status message below grid -->
    <text
        x="@(ViewBoxWidth / 2)"
        y="@(ViewBoxHeight + TitleFontSize + 8)"
        text-anchor="middle"
        fill="@StatusTextColor"
        font-size="@TitleFontSize"
        font-family="sans-serif"
        font-weight="bold">
        @StatusText
    </text>
</svg>

@code {
    [Parameter, EditorRequired]
    public YardTopology Topology { get; set; } = YardTopology.Empty;

    [Parameter]
    public int CellSize { get; set; } = 40;

    [Parameter]
    public int TrackThickness { get; set; } = 6;

    [Parameter]
    public bool ShowGrid { get; set; } = true;

    [Parameter]
    public LabelTranslator? LabelTranslator { get; set; }

    private string? _selectedFromSignal;
    private string? _feedbackMessage;
    private string _feedbackCssClass = "";
    private System.Threading.Timer? _feedbackTimer;
    private readonly Dictionary<(int from, int to), HashSet<TrackLink>> _routeLinks = new();
    private HashSet<TrackLink> _activeRouteLinks = new();

    protected override void OnInitialized()
    {
        TrainRouteNotifications.RouteChanged += OnRouteChanged;
        PointPositionService.PositionChanged += OnPointPositionChanged;
        SignalStateService.SignalStateChanged += OnSignalStateChanged;
    }

    private void OnPointPositionChanged(PointPositionFeedback feedback)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnSignalStateChanged(SignalStateFeedback feedback)
    {
        InvokeAsync(StateHasChanged);
    }

    private Signal GetSignal(SignalDefinition definition)
    {
        var signal = Signal.FromDefinition(definition);
        if (int.TryParse(definition.Name, out var signalNumber))
            signal.State = SignalStateService.GetSignalState(signalNumber);
        return signal;
    }

    private void OnSignalClicked(SignalClickEventArgs args)
    {
        var signalName = args.SignalName;

        // CTRL+click on a signal that is part of an active route cancels that route
        if (args.CtrlKey)
        {
            if (int.TryParse(signalName, out var signalNumber))
            {
                var activeRoute = _routeLinks.Keys.FirstOrDefault(k => k.from == signalNumber || k.to == signalNumber);
                if (activeRoute != default)
                {
                    var command = $"{activeRoute.to}/";
                    var keys = command.Select(c => new ConsoleKeyInfo(c, c.ConsoleKey, false, false, false));
                    BufferedKeyReader.EnqueueKeys(keys);
                    _selectedFromSignal = null;
                    return;
                }
            }
            _selectedFromSignal = null;
            return;
        }

        // Shift+click toggles signal between Stop and Go
        if (args.ShiftKey)
        {
            if (int.TryParse(signalName, out var signalNumber))
            {
                var signal = YardDataService.Signals.FirstOrDefault(s => s.Name == signalName);
                if (signal is not null)
                {
                    var currentState = SignalStateService.GetSignalState(signalNumber);
                    var newState = currentState == SignalState.Go ? SignalState.Stop : SignalState.Go;
                    var command = new SignalCommand(signalNumber, signal.Address, newState) { FeedbackAddress = signal.FeedbackAddress };
                    _ = YardController.SendSignalCommandAsync(command, CancellationToken.None);
                }
            }
            _selectedFromSignal = null;
            return;
        }

        // Only allow clicking Stop (red) signals
        if (int.TryParse(signalName, out var sigNum) && SignalStateService.GetSignalState(sigNum) == SignalState.Go)
            return;

        if (_selectedFromSignal is null)
        {
            _selectedFromSignal = signalName;
        }
        else if (_selectedFromSignal == signalName)
        {
            _selectedFromSignal = null;
        }
        else
        {
            var command = $"{_selectedFromSignal}.{signalName}=";
            var keys = command.Select(c => new ConsoleKeyInfo(c, c.ConsoleKey, false, false, false));
            BufferedKeyReader.EnqueueKeys(keys);
            _selectedFromSignal = null;
        }
    }

    private void OnRouteChanged(TrainRouteResult result)
    {
        InvokeAsync(() =>
        {
            switch (result.ResultType)
            {
                case TrainRouteResultType.Set:
                    var links = FindRouteLinks(result.Route);
                    _routeLinks[(result.Route.FromSignal, result.Route.ToSignal)] = links;
                    RecomputeActiveRouteLinks();
                    SetFeedback(result.Message ?? "", "status-set");
                    break;
                case TrainRouteResultType.Rejected:
                    SetFeedback(result.Message ?? "", "status-rejected");
                    break;
                case TrainRouteResultType.Cleared:
                    var clearedFrom = result.Route.FromSignal;
                    var clearedTo = result.Route.ToSignal;
                    // When cleared by TO signal only (FromSignal==0), find the actual route
                    if (clearedFrom == 0)
                    {
                        var match = _routeLinks.Keys.FirstOrDefault(k => k.to == clearedTo);
                        if (match != default) clearedFrom = match.from;
                    }
                    _routeLinks.Remove((clearedFrom, clearedTo));
                    RecomputeActiveRouteLinks();
                    SetFeedback(result.Message ?? "", "status-cleared");
                    break;
                case TrainRouteResultType.AllCleared:
                    _routeLinks.Clear();
                    _activeRouteLinks = new();
                    SetFeedback(result.Message ?? "", "status-cleared");
                    break;
            }
            StateHasChanged();
        });
    }

    private void SetFeedback(string message, string cssClass)
    {
        _feedbackMessage = message;
        _feedbackCssClass = cssClass;
        _feedbackTimer?.Dispose();
        _feedbackTimer = new System.Threading.Timer(_ =>
        {
            InvokeAsync(() =>
            {
                _feedbackMessage = null;
                StateHasChanged();
            });
        }, null, 5000, Timeout.Infinite);
    }

    public void Dispose()
    {
        TrainRouteNotifications.RouteChanged -= OnRouteChanged;
        PointPositionService.PositionChanged -= OnPointPositionChanged;
        SignalStateService.SignalStateChanged -= OnSignalStateChanged;
        _feedbackTimer?.Dispose();
    }

    private int ViewBoxWidth => (Topology.MaxColumn + 1) * CellSize;
    private int ViewBoxHeight => (Topology.MaxRow + 1) * CellSize;
    private int StatusBarHeight => TitleFontSize + 16;
    private int TotalViewBoxHeight => ViewBoxHeight + StatusBarHeight;
    private int TitleFontSize => 20;

    private string StatusText => _feedbackMessage is not null
        ? _feedbackMessage
        : _selectedFromSignal is not null
            ? string.Format(Messages.SelectToSignal, _selectedFromSignal)
            : _routeLinks.Count > 0
                ? Messages.SelectFromSignalWithClearHint
                : Messages.SelectFromSignal;

    private string StatusTextColor => _feedbackMessage is not null
        ? _feedbackCssClass switch
        {
            "status-set" => "#00cc00",
            "status-rejected" => "#ff4444",
            "status-cleared" => "#88aaff",
            _ => "#888"
        }
        : _selectedFromSignal is not null
            ? "yellow"
            : "#888";
    private int PointLabelFontSize => 12;
    private int FontSize => 10;
    private int GapSize => 8; // Size of gap indicator
    private int PointLabelOffset => 18 + TrackThickness * 2;

    private static string F(double value) => value.ToString("F2", CultureInfo.InvariantCulture);

    private string TranslateLabel(string text) =>
        LabelTranslator?.Translate(text, CultureInfo.CurrentUICulture.TwoLetterISOLanguageName) ?? text;

    private static (int Number, char? SubPoint) GetPointNumberAndSubPoint(string label)
    {
        var digits = new string(label.TakeWhile(char.IsDigit).ToArray());
        var number = int.TryParse(digits, out var n) ? n : 0;
        char? subPoint = digits.Length < label.Length && char.IsLetter(label[digits.Length])
            ? char.ToLower(label[digits.Length]) : null;
        return (number, subPoint);
    }

    private (int x, int y) ToPixel(GridCoordinate coord)
        => (coord.Column * CellSize, coord.Row * CellSize);

    private (double x, double y, double angle) CalculatePointLabelPosition(int sx, int sy, int strX, int strY, int divX, int divY)
    {
        var strDx = strX - sx;
        var strDy = strY - sy;
        var strLen = Math.Sqrt(strDx * strDx + strDy * strDy);

        var divDx = divX - sx;
        var divDy = divY - sy;
        var divLen = Math.Sqrt(divDx * divDx + divDy * divDy);

        if (strLen == 0 || divLen == 0)
            return (sx, sy, 0);

        var strUx = strDx / strLen;
        var strUy = strDy / strLen;
        var divUx = divDx / divLen;
        var divUy = divDy / divLen;

        var bisectX = strUx + divUx;
        var bisectY = strUy + divUy;
        var bisectLen = Math.Sqrt(bisectX * bisectX + bisectY * bisectY);

        if (bisectLen == 0)
            return (sx, sy, 0);

        var normBisectX = bisectX / bisectLen;
        var normBisectY = bisectY / bisectLen;

        var labelX = sx + normBisectX * PointLabelOffset;
        var labelY = sy + normBisectY * PointLabelOffset;

        var angle = Math.Atan2(normBisectY, normBisectX) * 180 / Math.PI;

        if (angle > 90)
            angle -= 180;
        else if (angle < -90)
            angle += 180;

        return (labelX, labelY, angle);
    }

    private (double x, double y) ToPixelCentered(GridCoordinate coord, bool toRight)
    {
        var offset = toRight ? 0.5 : -0.5;
        return ((coord.Column + offset) * CellSize, coord.Row * CellSize);
    }

    private HashSet<TrackLink> FindRouteLinks(TrainRouteCommand route)
    {
        var fromSignalDef = Topology.Signals.FirstOrDefault(s => s.Name == route.FromSignal.ToString());
        var toSignalDef = Topology.Signals.FirstOrDefault(s => s.Name == route.ToSignal.ToString());
        if (fromSignalDef?.Coordinate is not { } fromCoord || toSignalDef?.Coordinate is not { } toCoord)
            return new();

        // Build list of waypoints: from → intermediates → to
        var waypoints = new List<(GridCoordinate Coord, bool DrivesRight)> { (fromCoord, fromSignalDef.DrivesRight) };
        foreach (var intermediateSignal in route.IntermediateSignals)
        {
            var sig = Topology.Signals.FirstOrDefault(s => s.Name == intermediateSignal.ToString());
            if (sig is not null)
                waypoints.Add((sig.Coordinate, sig.DrivesRight));
        }
        waypoints.Add((toCoord, toSignalDef.DrivesRight));

        // Trace each segment and combine
        var result = new HashSet<TrackLink>();
        for (var i = 0; i < waypoints.Count - 1; i++)
        {
            var segmentPath = Topology.Graph.FindRoutePath(waypoints[i].Coord, waypoints[i + 1].Coord, waypoints[i].DrivesRight);
            foreach (var link in segmentPath)
                result.Add(link);
        }
        return result;
    }

    private void RecomputeActiveRouteLinks()
    {
        var union = new HashSet<TrackLink>();
        foreach (var links in _routeLinks.Values)
            union.UnionWith(links);
        _activeRouteLinks = union;
    }

    /// <summary>
    /// Finds a link that would contain the specified coordinate (between its endpoints).
    /// For example, coordinate 2.1 would be found on link 2.0-2.2.
    /// </summary>
    private TrackLink? FindLinkContaining(GridCoordinate coord)
    {
        foreach (var link in Topology.Graph.Links)
        {
            var from = link.FromNode.Coordinate;
            var to = link.ToNode.Coordinate;

            // Check if coord is on the line between from and to
            // Same row, column between from and to
            if (from.Row == to.Row && coord.Row == from.Row)
            {
                var minCol = Math.Min(from.Column, to.Column);
                var maxCol = Math.Max(from.Column, to.Column);
                if (coord.Column > minCol && coord.Column < maxCol)
                    return link;
            }
            // Same column, row between from and to
            else if (from.Column == to.Column && coord.Column == from.Column)
            {
                var minRow = Math.Min(from.Row, to.Row);
                var maxRow = Math.Max(from.Row, to.Row);
                if (coord.Row > minRow && coord.Row < maxRow)
                    return link;
            }
            // Diagonal - check if point is on line segment
            else
            {
                var dx = to.Column - from.Column;
                var dy = to.Row - from.Row;
                var px = coord.Column - from.Column;
                var py = coord.Row - from.Row;

                // Check if point is on line (cross product = 0) and between endpoints
                if (dx * py == dy * px) // On the line
                {
                    var t = dx != 0 ? (double)px / dx : (double)py / dy;
                    if (t > 0 && t < 1)
                        return link;
                }
            }
        }
        return null;
    }

}
